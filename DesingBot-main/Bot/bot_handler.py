import os
import logging
import telebot
import time
from telebot import types
from typing import List, Dict, Any, Set, Optional
from ai_embedding.extract import process_documents, search_similar_chunks_sklearn
from ai_embedding.ai import answer_general_question, embed_question
from constants import DOCUMENTS_FOLDER, DESIGN_CATEGORIES, CATEGORY_EMOJIS, CATEGORY_DESCRIPTIONS
from core.state_manager import StateManager
from core.onboarding import OnboardingSystem
from core.search_service import AdvancedSearchService
from core.admin_service import AdminService
from ai_embedding.adaptive_ai import AdaptiveAIService


def sanitize_markdown(text):
    """Sanitiza el texto para evitar errores de markdown en Telegram"""
    if not text:
        return ""
    
    # Si el texto es muy largo, dividirlo en partes
    if len(text) > 4000:
        parts = []
        current_part = ""
        
        lines = text.split('\n')
        for line in lines:
            if len(current_part + line + '\n') > 4000:
                if current_part:
                    parts.append(current_part.strip())
                current_part = line + '\n'
            else:
                current_part += line + '\n'
        
        if current_part:
            parts.append(current_part.strip())
        
        return parts
    
    return text


class BotHandler:
    def __init__(self, bot=None):
        """
        Inicializa el manejador del DesignBot UX/UI con funcionalidades avanzadas

        Args:
            bot: Instancia de TeleBot pasada desde main.py
        """
        self._init_logging()
        self.bot = bot
        self.processing_users = set()
        
        # Inicializar servicios core
        print("üé® Inicializando DesignBot con funcionalidades avanzadas...")
        self.state_manager = StateManager()
        self.search_service = AdvancedSearchService(self.state_manager)
        self.onboarding_system = OnboardingSystem(bot, self.state_manager)
        self.admin_service = AdminService(bot, self.state_manager, self.search_service)
        self.adaptive_ai = AdaptiveAIService(self.state_manager, self.search_service)
        
        self._init_data()

    def _init_logging(self):
        """Configura el logger para esta clase"""
        self.logger = logging.getLogger(__name__)

    def _init_data(self):
        """Inicializa el acceso a los datos procesados"""
        try:
            # Procesamiento de PDFs/vectores realizado solo una vez al inicio
            self.index_model, self.chunks = process_documents()
            if not self.index_model or not self.chunks:
                self.logger.warning("No se pudieron cargar √≠ndices o documentos")
        except Exception as e:
            self.logger.error(f"Error inicializando datos: {str(e)}")
            self.index_model = None
            self.chunks = []

    def process_all_pdfs(self):
        """Procesa todos los PDFs para crear embeddings e √≠ndices"""
        self.index_model, self.chunks = process_documents()
        return bool(self.index_model and self.chunks)

    def start(self, message_or_call):
        """Maneja el comando start con onboarding avanzado"""
        chat_id = (
            message_or_call.chat.id
            if hasattr(message_or_call, "chat")
            else message_or_call.message.chat.id
        )
        user_id = (
            message_or_call.from_user.id
            if hasattr(message_or_call, "from_user")
            else message_or_call.message.from_user.id
        )

        # Actualizar analytics
        self.admin_service.update_analytics('start_command', {'user_id': user_id})
        
        # Iniciar onboarding inteligente
        self.onboarding_system.start_onboarding(message_or_call)

    def handle_general_question(self, message):
        """Maneja preguntas generales con IA adaptativa"""
        start_time = time.perf_counter()
        
        # Determinar el comando y extraer la pregunta
        text = message.text
        question = ""
        command_type = "general"
        
        if text.startswith("/design "):
            question = text.replace("/design ", "")
            command_type = "design"
        elif text.startswith("/ux "):
            question = text.replace("/ux ", "")
            command_type = "ux"
        elif text.startswith("/ui "):
            question = text.replace("/ui ", "")
            command_type = "ui"
        elif text.startswith("/tools "):
            question = text.replace("/tools ", "")
            command_type = "tools"
        elif text.startswith("/ask "):
            question = text.replace("/ask ", "")
            command_type = "general"
        else:
            question = text.replace("/ask", "").strip()
        
        if not question:
            help_messages = {
                "design": "‚ùå **Formato correcto:** `/design [tu pregunta sobre dise√±o]`\n\nüìù *Ejemplo:* `/design principios de dise√±o visual`",
                "ux": "‚ùå **Formato correcto:** `/ux [tu pregunta sobre UX]`\n\nüìù *Ejemplo:* `/ux c√≥mo hacer user research efectivo`",
                "ui": "‚ùå **Formato correcto:** `/ui [tu pregunta sobre UI]`\n\nüìù *Ejemplo:* `/ui mejores pr√°cticas para botones`",
                "tools": "‚ùå **Formato correcto:** `/tools [tu pregunta sobre herramientas]`\n\nüìù *Ejemplo:* `/tools c√≥mo usar componentes en Figma`",
                "general": "‚ùå **Formato correcto:** `/ask [tu pregunta]`\n\nüìù *Ejemplo:* `/ask diferencia entre UX y UI`"
            }
            
            self.bot.send_message(
                message.chat.id,
                help_messages.get(command_type, help_messages["general"]),
                parse_mode="Markdown",
            )
            return

        user_id = message.from_user.id
        if user_id in self.processing_users:
            self.bot.send_message(
                message.chat.id,
                "‚è≥ Ya estoy procesando tu consulta anterior. Por favor espera...",
            )
            return

        self.processing_users.add(user_id)
        
        # Actualizar contexto y historial del usuario
        self.state_manager.update_user_context(user_id, f"question_{command_type}")
        self.state_manager.add_to_history(user_id, question)
        
        # Mensaje contextual seg√∫n el tipo de comando
        context_messages = {
            "design": "üé® Analizando principios de dise√±o...",
            "ux": "üë• Consultando mejores pr√°cticas de UX...",
            "ui": "üñºÔ∏è Revisando patrones de interfaz...",
            "tools": "üõ†Ô∏è Buscando gu√≠as de herramientas...",
            "general": "üí≠ Procesando tu consulta de dise√±o..."
        }
        
        try:
            self.bot.send_chat_action(message.chat.id, "typing")
            status_msg = self.bot.send_message(
                message.chat.id, 
                context_messages.get(command_type, context_messages["general"])
            )

            self.logger.info(f"Generando respuesta adaptativa de {command_type} para usuario {user_id}: {question[:50]}...")
            
            # Usar IA adaptativa para generar respuesta personalizada
            respuesta = self.adaptive_ai.generate_adaptive_response(
                question, command_type, user_id
            )

            # Eliminar mensaje de estado
            try:
                self.bot.delete_message(message.chat.id, status_msg.message_id)
            except:
                pass

            safe_response = sanitize_markdown(respuesta)

            if isinstance(safe_response, list):
                for part in safe_response:
                    self.bot.send_message(message.chat.id, part, parse_mode="Markdown")
            else:
                self.bot.send_message(
                    message.chat.id, safe_response, parse_mode="Markdown"
                )

            # Actualizar analytics con tiempo de respuesta
            response_time = time.perf_counter() - start_time
            self.admin_service.update_analytics('ai_response', {
                'user_id': user_id,
                'command_type': command_type,
                'response_time': response_time,
                'success': True
            })

        except Exception as e:
            self.logger.error(f"Error en handle_general_question para usuario {user_id}: {str(e)}")
            # Eliminar mensaje de estado si existe
            try:
                self.bot.delete_message(message.chat.id, status_msg.message_id)
            except:
                pass
            
            # Mensaje de error m√°s espec√≠fico
            error_msg = "‚ùå No pude generar una respuesta en este momento."
            if "timeout" in str(e).lower() or "connection" in str(e).lower():
                error_msg += "\n\n‚è±Ô∏è El servicio est√° experimentando alta demanda. Por favor, intenta nuevamente en unos momentos."
            else:
                error_msg += "\n\nüí° Intenta reformular tu pregunta de dise√±o o usar `/help` para ver otros comandos."
            
            self.bot.send_message(message.chat.id, error_msg)
            
            # Actualizar analytics de error
            self.admin_service.update_analytics('ai_response', {
                'user_id': user_id,
                'command_type': command_type,
                'success': False,
                'error': str(e)
            })
        finally:
            elapsed = time.perf_counter() - start_time
            self.logger.info(
                f"Tiempo de respuesta de handle_general_question para usuario {user_id}: {elapsed:.3f} segundos"
            )
            self.processing_users.discard(user_id)

    def handle_embedding_search(self, message):
        """Busca documentos con b√∫squeda contextual avanzada"""
        start_time = time.perf_counter()
        question = message.text.replace("/search ", "")
        if not question or question == "/search":
            # Mostrar sugerencias de b√∫squeda personalizadas
            user_id = message.from_user.id
            suggestions = self.search_service.get_search_suggestions(user_id)
            trending = self.search_service.get_trending_searches()
            
            suggestion_text = (
                "üîç **B√∫squeda Inteligente**\n\n"
                "‚ùå Formato correcto: `/search [tu consulta]`\n\n"
            )
            
            if suggestions:
                suggestion_text += "üí° **Sugerencias personalizadas:**\n"
                for suggestion in suggestions[:5]:
                    suggestion_text += f"‚Ä¢ {suggestion}\n"
                suggestion_text += "\n"
            
            if trending:
                suggestion_text += "üî• **B√∫squedas populares:**\n"
                for trend in trending[:5]:
                    suggestion_text += f"‚Ä¢ {trend}\n"
            
            suggestion_text += "\nüìù *Ejemplo:* `/search atomic design system`"
            
            self.bot.send_message(message.chat.id, suggestion_text, parse_mode="Markdown")
            return

        user_id = message.from_user.id
        if user_id in self.processing_users:
            self.bot.send_message(
                message.chat.id,
                "‚è≥ Ya estoy procesando tu consulta anterior. Por favor espera...",
            )
            return

        self.processing_users.add(user_id)
        
        # Actualizar contexto y estad√≠sticas de b√∫squeda
        self.state_manager.update_user_context(user_id, "search")
        self.state_manager.update_search_stats(user_id, question)
        
        status_msg = None
        try:
            self.bot.send_chat_action(message.chat.id, "typing")
            status_msg = self.bot.send_message(
                message.chat.id,
                "üîç Realizando b√∫squeda contextual inteligente..."
            )

            self.logger.info(f"B√∫squeda contextual para usuario {user_id}: {question[:50]}...")

            # Usar b√∫squeda contextual avanzada
            enhanced_query, enhanced_filters = self.search_service.contextual_search(
                question, user_id
            )

            # Verificaci√≥n de datos disponibles
            if not self.index_model or not self.chunks:
                try:
                    self.bot.delete_message(message.chat.id, status_msg.message_id)
                except:
                    pass
                self.bot.send_message(
                    message.chat.id,
                    "‚ö†Ô∏è No hay documentos procesados disponibles para b√∫squeda.",
                )
                return

            # Generaci√≥n de embedding para la b√∫squeda mejorada
            question_embedding = embed_question(enhanced_query)
            if not question_embedding:
                try:
                    self.bot.delete_message(message.chat.id, status_msg.message_id)
                except:
                    pass
                self.bot.send_message(
                    message.chat.id,
                    "‚ùå No pude procesar tu consulta. Intenta con otra pregunta.",
                )
                return

            # B√∫squeda sem√°ntica de documentos relevantes
            similar_chunks = search_similar_chunks_sklearn(
                question_embedding, self.index_model, self.chunks, top_k=5
            )

            if not similar_chunks:
                try:
                    self.bot.delete_message(message.chat.id, status_msg.message_id)
                except:
                    pass
                self.bot.send_message(
                    message.chat.id,
                    "‚ùì No encontr√© documentos relacionados con tu consulta.",
                )
                return

            # Actualizar mensaje de estado
            try:
                self.bot.edit_message_text(
                    "ü§ñ Generando respuesta personalizada con IA adaptativa...",
                    message.chat.id,
                    status_msg.message_id
                )
            except:
                pass

            # Generar respuesta usando IA adaptativa con contexto de documentos
            answer = self.adaptive_ai.generate_adaptive_response(
                question, "search", user_id, similar_chunks
            )

            # Eliminar mensaje de estado
            try:
                self.bot.delete_message(message.chat.id, status_msg.message_id)
            except:
                pass

            # Enviar la respuesta principal (dividida si es necesaria)
            if len(answer) > 4000:
                chunks = [answer[i : i + 4000] for i in range(0, len(answer), 4000)]
                for chunk in chunks:
                    self.bot.send_message(message.chat.id, chunk, parse_mode="Markdown")
            else:
                self.bot.send_message(
                    message.chat.id, answer, parse_mode="Markdown"
                )

            # Manejo mejorado de referencias
            if similar_chunks:
                # Diccionario para agrupar referencias por documento
                doc_refs = {}  # {documento: set(p√°ginas)}

                # Extraer informaci√≥n √∫nica de documentos y p√°ginas
                for chunk in similar_chunks:
                    doc_name = chunk.get("document", "")
                    if not doc_name:
                        continue

                    # Convertir a nombre base del documento
                    base_name = os.path.basename(doc_name)
                    pretty_name = base_name.replace(".pdf", "").replace("_", " ")

                    # Extraer p√°ginas √∫nicas
                    pages = chunk.get("pages", [])

                    # Agregar al diccionario, combinando las p√°ginas si ya existe
                    if pretty_name in doc_refs:
                        doc_refs[pretty_name].update(pages)
                    else:
                        doc_refs[pretty_name] = set(pages)

                # Crear mensaje de referencias
                if doc_refs:
                    ref_text = "üìö Referencias consultadas:\n\n"

                    for doc_name, pages in doc_refs.items():
                        # Ordenar p√°ginas para presentaci√≥n
                        sorted_pages = sorted(pages)
                        pages_str = (
                            ", ".join(map(str, sorted_pages)) if sorted_pages else "N/A"
                        )
                        ref_text += f"‚Ä¢ {doc_name} (P√°g: {pages_str})\n"

                    # Enviar mensaje con referencias √∫nicas
                    self.bot.send_message(message.chat.id, ref_text)

                    # Crear botones de descarga (solo uno por documento)
                    keyboard = types.InlineKeyboardMarkup()

                    for doc_pretty_name in doc_refs.keys():
                        # Buscar documento en sistema de archivos
                        for pdf_path in self.find_pdf_files(DOCUMENTS_FOLDER):
                            base_name = os.path.basename(pdf_path)
                            pdf_pretty_name = base_name.replace(".pdf", "").replace(
                                "_", " "
                            )

                            if pdf_pretty_name == doc_pretty_name:
                                # Encontramos el documento, crear bot√≥n de descarga
                                rel_path = os.path.relpath(pdf_path, DOCUMENTS_FOLDER)
                                keyboard.add(
                                    types.InlineKeyboardButton(
                                        f"üì• Descargar {doc_pretty_name}",
                                        callback_data=f"download#{rel_path}",
                                    )
                                )
                                break

                    # Enviar botones solo si hay documentos para descargar
                    if keyboard.keyboard:
                        self.bot.send_message(
                            message.chat.id,
                            "Selecciona un documento para descargar:",
                            reply_markup=keyboard,
                        )

            # Actualizar analytics de b√∫squeda
            response_time = time.perf_counter() - start_time
            self.admin_service.update_analytics('search', {
                'user_id': user_id,
                'query': question,
                'enhanced_query': enhanced_query,
                'results_count': len(similar_chunks),
                'response_time': response_time,
                'success': True
            })

        except Exception as e:
            self.logger.error(f"Error en handle_embedding_search para usuario {user_id}: {str(e)}")
            
            # Eliminar mensaje de estado si existe
            if status_msg:
                try:
                    self.bot.delete_message(message.chat.id, status_msg.message_id)
                except:
                    pass
            
            # Mensaje de error espec√≠fico
            error_msg = "‚ùå Error al procesar tu b√∫squeda."
            if "timeout" in str(e).lower() or "connection" in str(e).lower():
                error_msg += "\n\n‚è±Ô∏è El servicio est√° experimentando alta demanda. Por favor, intenta nuevamente en unos momentos."
            else:
                error_msg += "\n\nüí° Intenta reformular tu consulta o usar `/help` para ver otros comandos."
            
            self.bot.send_message(message.chat.id, error_msg)

            self.admin_service.update_analytics('search', {
                'user_id': user_id,
                'query': question,
                'success': False,
                'error': str(e)
            })
        finally:
            elapsed = time.perf_counter() - start_time
            self.logger.info(
                f"Tiempo de respuesta de handle_embedding_search para usuario {user_id}: {elapsed:.3f} segundos"
            )
            self.processing_users.discard(user_id)

    # Nuevos m√©todos para funcionalidades avanzadas
    def handle_preferences_command(self, message):
        """Maneja configuraci√≥n de preferencias de usuario"""
        user_id = message.from_user.id
        session = self.state_manager.get_user_session(user_id)
        analytics = self.state_manager.get_user_analytics(user_id)
        
        preferences_text = (
            "‚öôÔ∏è **Tus Preferencias Actuales**\n\n"
            f"üë§ **Perfil:**\n"
            f"‚Ä¢ Nivel de experiencia: {session.expertise_level.title()}\n"
            f"‚Ä¢ Herramientas favoritas: {', '.join(session.favorite_tools) if session.favorite_tools else 'No definidas'}\n"
            f"‚Ä¢ √Åreas de inter√©s: {', '.join(session.preferences.get('interests', [])) if session.preferences.get('interests') else 'No definidas'}\n\n"
            f"üìä **Tu Actividad:**\n"
            f"‚Ä¢ B√∫squedas realizadas: {analytics['searches_count']}\n"
            f"‚Ä¢ Tiempo en sesi√≥n: {analytics['session_duration']/60:.1f} minutos\n"
            f"‚Ä¢ Mensajes intercambiados: {analytics['conversation_length']}\n\n"
            "üéõÔ∏è **Configuraciones disponibles:**"
        )
        
        keyboard = types.InlineKeyboardMarkup()
        keyboard.add(
            types.InlineKeyboardButton("üéØ Cambiar nivel", callback_data="pref_level"),
            types.InlineKeyboardButton("üõ†Ô∏è Editar herramientas", callback_data="pref_tools")
        )
        keyboard.add(
            types.InlineKeyboardButton("üí° Cambiar intereses", callback_data="pref_interests"),
            types.InlineKeyboardButton("üé® Estilo respuestas", callback_data="pref_style")
        )
        keyboard.add(
            types.InlineKeyboardButton("üîÑ Reiniciar onboarding", callback_data="pref_reset_onboarding")
        )
        
        self.bot.send_message(
            message.chat.id,
            preferences_text,
            reply_markup=keyboard,
            parse_mode="Markdown"
        )

    def handle_admin_command(self, message):
        """Maneja comandos de administraci√≥n"""
        self.admin_service.handle_admin_command(message)

    def handle_callback_query(self, call):
        """Maneja todas las consultas de callback de forma centralizada"""
        user_id = call.from_user.id
        
        # Callbacks del onboarding
        if call.data.startswith("onb_"):
            self.onboarding_system.handle_onboarding_callback(call)
            
        # Callbacks de preferencias
        elif call.data.startswith("pref_"):
            self._handle_preferences_callback(call)
            
        # Callbacks de administraci√≥n
        elif call.data.startswith("admin_"):
            if self.admin_service.is_admin(user_id):
                self._handle_admin_callback(call)
            else:
                self.bot.answer_callback_query(call.id, "‚ùå Sin permisos de admin")
                
        # Callbacks existentes
        elif call.data.startswith("list_"):
            self.handle_list(call)
        elif call.data.startswith("download#"):
            self.handle_pdf_download(call)
        elif call.data.startswith("back_"):
            self.handle_back(call)
        else:
            self.bot.answer_callback_query(call.id, "Comando no reconocido")

    def _handle_preferences_callback(self, call):
        """Maneja callbacks de configuraci√≥n de preferencias"""
        action = call.data.replace("pref_", "")
        user_id = call.from_user.id
        
        if action == "level":
            self._show_level_selection(call)
        elif action == "tools":
            self._show_tools_selection(call)
        elif action == "interests":
            self._show_interests_selection(call)
        elif action == "style":
            self._show_style_selection(call)
        elif action == "reset_onboarding":
            self._reset_user_onboarding(call)

    def _show_level_selection(self, call):
        """Muestra selecci√≥n de nivel de experiencia"""
        level_text = "üéØ **Selecciona tu nivel de experiencia:**"
        
        keyboard = types.InlineKeyboardMarkup()
        keyboard.add(
            types.InlineKeyboardButton("üå± Principiante", callback_data="set_level_beginner")
        )
        keyboard.add(
            types.InlineKeyboardButton("üöÄ Intermedio", callback_data="set_level_intermediate")
        )
        keyboard.add(
            types.InlineKeyboardButton("‚≠ê Avanzado", callback_data="set_level_expert")
        )
        keyboard.add(
            types.InlineKeyboardButton("‚¨ÖÔ∏è Volver", callback_data="pref_back")
        )
        
        try:
            self.bot.edit_message_text(
                level_text,
                call.message.chat.id,
                call.message.message_id,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )
        except:
            self.bot.send_message(
                call.message.chat.id,
                level_text,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )

    def _show_tools_selection(self, call):
        """Muestra selecci√≥n de herramientas favoritas"""
        user_id = call.from_user.id
        session = self.state_manager.get_user_session(user_id)
        selected_tools = session.favorite_tools
        
        tools_text = (
            "üõ†Ô∏è **Selecciona tus herramientas favoritas:**\n\n"
            f"Actualmente seleccionadas: {', '.join(selected_tools) if selected_tools else 'Ninguna'}"
        )
        
        tools = ["Figma", "Sketch", "Adobe XD", "InVision", "Framer", "Principle"]
        
        keyboard = types.InlineKeyboardMarkup()
        for tool in tools:
            emoji = "‚úÖ" if tool in selected_tools else "‚ö™"
            keyboard.add(
                types.InlineKeyboardButton(
                    f"{emoji} {tool}",
                    callback_data=f"toggle_tool_{tool}"
                )
            )
        
        keyboard.add(
            types.InlineKeyboardButton("üíæ Guardar", callback_data="save_tools"),
            types.InlineKeyboardButton("‚¨ÖÔ∏è Volver", callback_data="pref_back")
        )
        
        try:
            self.bot.edit_message_text(
                tools_text,
                call.message.chat.id,
                call.message.message_id,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )
        except:
            self.bot.send_message(
                call.message.chat.id,
                tools_text,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )

    def _show_interests_selection(self, call):
        """Muestra selecci√≥n de √°reas de inter√©s"""
        user_id = call.from_user.id
        session = self.state_manager.get_user_session(user_id)
        selected_interests = session.preferences.get('interests', [])
        
        interests_text = (
            "üí° **Selecciona tus √°reas de inter√©s:**\n\n"
            f"Actualmente seleccionadas: {', '.join(selected_interests) if selected_interests else 'Ninguna'}"
        )
        
        interests = ["UX Research", "UI Design", "Design Systems", "Prototyping", "Usability Testing", "Mobile Design"]
        
        keyboard = types.InlineKeyboardMarkup()
        for interest in interests:
            emoji = "‚úÖ" if interest in selected_interests else "‚ö™"
            keyboard.add(
                types.InlineKeyboardButton(
                    f"{emoji} {interest}",
                    callback_data=f"toggle_interest_{interest.replace(' ', '_')}"
                )
            )
        
        keyboard.add(
            types.InlineKeyboardButton("üíæ Guardar", callback_data="save_interests"),
            types.InlineKeyboardButton("‚¨ÖÔ∏è Volver", callback_data="pref_back")
        )
        
        try:
            self.bot.edit_message_text(
                interests_text,
                call.message.chat.id,
                call.message.message_id,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )
        except:
            self.bot.send_message(
                call.message.chat.id,
                interests_text,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )

    def _show_style_selection(self, call):
        """Muestra selecci√≥n de estilo de respuesta"""
        user_id = call.from_user.id
        session = self.state_manager.get_user_session(user_id)
        current_style = session.preferences.get('response_style', 'professional')
        
        style_text = (
            "üé® **Selecciona tu estilo de respuesta preferido:**\n\n"
            f"Estilo actual: **{current_style.title()}**\n\n"
            "**Estilos disponibles:**\n"
            "‚Ä¢ **Profesional:** Terminolog√≠a t√©cnica e industria\n"
            "‚Ä¢ **Casual:** Conversacional y amigable\n"
            "‚Ä¢ **Acad√©mico:** Rigor te√≥rico y referencias\n"
            "‚Ä¢ **Pr√°ctico:** Enfoque en ejemplos reales"
        )
        
        styles = [
            ("professional", "Profesional"),
            ("casual", "Casual"),
            ("academic", "Acad√©mico"),
            ("practical", "Pr√°ctico")
        ]
        
        keyboard = types.InlineKeyboardMarkup()
        for style_id, style_name in styles:
            emoji = "‚úÖ" if style_id == current_style else "‚ö™"
            keyboard.add(
                types.InlineKeyboardButton(
                    f"{emoji} {style_name}",
                    callback_data=f"set_style_{style_id}"
                )
            )
        
        keyboard.add(
            types.InlineKeyboardButton("‚¨ÖÔ∏è Volver", callback_data="pref_back")
        )
        
        try:
            self.bot.edit_message_text(
                style_text,
                call.message.chat.id,
                call.message.message_id,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )
        except:
            self.bot.send_message(
                call.message.chat.id,
                style_text,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )

    def _reset_user_onboarding(self, call):
        """Reinicia el proceso de onboarding para el usuario"""
        user_id = call.from_user.id
        session = self.state_manager.get_user_session(user_id)
        
        # Resetear configuraciones de onboarding
        session.preferences["onboarding_completed"] = False
        session.expertise_level = "intermediate"
        session.favorite_tools = []
        session.preferences["interests"] = []
        
        # Guardar cambios
        self.state_manager._save_sessions()
        
        reset_text = (
            "üîÑ **Onboarding reiniciado**\n\n"
            "Tu perfil ha sido reseteado. Te guiar√© nuevamente por el proceso de configuraci√≥n."
        )
        
        try:
            self.bot.edit_message_text(
                reset_text,
                call.message.chat.id,
                call.message.message_id,
                parse_mode="Markdown"
            )
        except:
            self.bot.send_message(
                call.message.chat.id,
                reset_text,
                parse_mode="Markdown"
            )
        
        # Iniciar onboarding despu√©s de un momento
        time.sleep(2)
        self.onboarding_system.start_onboarding(call.message)

    def handle_analytics_command(self, message):
        """Muestra analytics personales del usuario"""
        user_id = message.from_user.id
        analytics = self.state_manager.get_user_analytics(user_id)
        session = self.state_manager.get_user_session(user_id)
        
        # Calcular tiempo de actividad
        session_hours = analytics['session_duration'] / 3600
        
        analytics_text = (
            "üìä **Tus Estad√≠sticas Personales**\n\n"
            f"üéØ **Perfil:**\n"
            f"‚Ä¢ Nivel: {analytics['expertise_level'].title()}\n"
            f"‚Ä¢ Herramientas: {', '.join(analytics['favorite_tools']) if analytics['favorite_tools'] else 'No definidas'}\n\n"
            f"üìà **Actividad:**\n"
            f"‚Ä¢ B√∫squedas realizadas: {analytics['searches_count']}\n"
            f"‚Ä¢ Conversaciones: {analytics['conversation_length']} mensajes\n"
            f"‚Ä¢ Tiempo total: {session_hours:.1f} horas\n"
            f"‚Ä¢ Promedio por sesi√≥n: {session_hours*60/max(1, analytics['searches_count']):.1f} min\n\n"
            f"üí° **Recomendaciones:**\n"
        )
        
        # Generar recomendaciones personalizadas
        if analytics['searches_count'] < 5:
            analytics_text += "‚Ä¢ Explora m√°s con `/search` para descubrir contenido relevante\n"
        
        if not analytics['favorite_tools']:
            analytics_text += "‚Ä¢ Define tus herramientas favoritas en `/preferences`\n"
        
        if analytics['expertise_level'] == 'beginner' and analytics['searches_count'] > 10:
            analytics_text += "‚Ä¢ Considera actualizar tu nivel a 'Intermedio' en preferencias\n"
        
        # Sugerencias de b√∫squeda
        suggestions = self.search_service.get_search_suggestions(user_id)
        if suggestions:
            analytics_text += f"\nüîç **Sugerencias para ti:**\n"
            for suggestion in suggestions[:3]:
                analytics_text += f"‚Ä¢ {suggestion}\n"
        
        self.bot.send_message(
            message.chat.id,
            analytics_text,
            parse_mode="Markdown"
        )

    def handle_trending_command(self, message):
        """Muestra contenido y b√∫squedas populares"""
        trending_searches = self.search_service.get_trending_searches()
        user_id = message.from_user.id
        user_suggestions = self.search_service.get_search_suggestions(user_id)
        
        trending_text = (
            "üî• **Tendencias en DesignBot**\n\n"
            "üìà **B√∫squedas populares esta semana:**\n"
        )
        
        for i, query in enumerate(trending_searches[:8], 1):
            trending_text += f"{i}. {query}\n"
        
        if user_suggestions:
            trending_text += f"\nüí° **Recomendado para ti:**\n"
            for suggestion in user_suggestions[:5]:
                trending_text += f"‚Ä¢ {suggestion}\n"
        
        trending_text += (
            f"\nüéØ **Tips:**\n"
            f"‚Ä¢ Usa `/search [t√©rmino]` para explorar cualquier tema\n"
            f"‚Ä¢ Combina t√©rminos para b√∫squedas m√°s espec√≠ficas\n"
            f"‚Ä¢ Revisa `/analytics` para ver tu progreso personal"
        )
        
        # Agregar botones de acci√≥n r√°pida
        keyboard = types.InlineKeyboardMarkup()
        if trending_searches:
            # Bot√≥n para la b√∫squeda m√°s popular
            top_search = trending_searches[0]
            keyboard.add(
                types.InlineKeyboardButton(
                    f"üîç Buscar: {top_search[:25]}...",
                    callback_data=f"quick_search_{top_search[:20]}"
                )
            )
        
        keyboard.add(
            types.InlineKeyboardButton("üìä Mis estad√≠sticas", callback_data="show_my_analytics"),
            types.InlineKeyboardButton("‚öôÔ∏è Preferencias", callback_data="show_preferences")
        )
        
        self.bot.send_message(
            message.chat.id,
            trending_text,
            reply_markup=keyboard,
            parse_mode="Markdown"
        )

    def handle_tips_command(self, message):
        """Proporciona tips contextuales basados en el perfil del usuario"""
        user_id = message.from_user.id
        session = self.state_manager.get_user_session(user_id)
        
        # Tips personalizados por nivel
        level_tips = {
            "beginner": [
                "üå± **Para principiantes:** Comienza con los fundamentos de UX/UI",
                "üìö Estudia los principios b√°sicos de dise√±o visual",
                "üë• Aprende sobre research de usuarios paso a paso",
                "üé® Familiar√≠zate con herramientas como Figma",
                "üì± Practica con proyectos peque√±os y recibe feedback"
            ],
            "intermediate": [
                "üöÄ **Para intermedios:** Profundiza en metodolog√≠as espec√≠ficas",
                "üìä Aprende a medir y validar tus dise√±os",
                "üéØ Crea tu primer design system personal",
                "üîÑ Domina procesos de iteraci√≥n y prototipado",
                "üíº Construye un portafolio s√≥lido con case studies"
            ],
            "expert": [
                "‚≠ê **Para expertos:** Enf√≥cate en liderazgo y estrategia",
                "üìà Conecta dise√±o con m√©tricas de negocio",
                "üë• Mentoriza a otros dise√±adores",
                "üèóÔ∏è Dise√±a sistemas escalables y arquitecturas",
                "üåç Contribuye a la comunidad de dise√±o"
            ]
        }
        
        # Tips por herramientas favoritas
        tool_tips = {
            "Figma": [
                "üí° **Figma:** Usa Auto Layout para componentes responsive",
                "üîß Configura design tokens para consistencia",
                "üìö Crea bibliotecas compartidas para tu equipo",
                "üé® Aprovecha los plugins para automatizar tareas"
            ],
            "Sketch": [
                "üí° **Sketch:** Organiza con Symbols y Libraries",
                "üîÑ Usa Sketch Cloud para colaboraci√≥n",
                "üìê Configura grids y guides consistentes",
                "üé® Explora plugins para funciones avanzadas"
            ],
            "Adobe XD": [
                "üí° **Adobe XD:** Aprovecha Voice Prototyping",
                "üîó Usa componentes para dise√±o sistem√°tico",
                "üì± Prototipos mobile con gestos avanzados",
                "‚òÅÔ∏è Colabora en tiempo real con Creative Cloud"
            ]
        }
        
        # Tips por intereses
        interest_tips = {
            "UX Research": [
                "üî¨ **UX Research:** Combina m√©todos cuali y cuantitativos",
                "üë• Entrevista usuarios regularmente",
                "üìä Valida hip√≥tesis con pruebas A/B",
                "üìù Documenta insights de forma sistem√°tica"
            ],
            "Design Systems": [
                "üéØ **Design Systems:** Comienza con atomic design",
                "üìè Define tokens antes que componentes",
                "üìö Documenta patrones y decisiones",
                "üîÑ Itera basado en feedback del equipo"
            ]
        }
        
        # Seleccionar tips relevantes
        selected_tips = []
        
        # Tips por nivel (sempre incluir)
        level = session.expertise_level
        if level in level_tips:
            selected_tips.extend(level_tips[level][:3])
        
        # Tips por herramientas
        for tool in session.favorite_tools[:2]:  # Max 2 herramientas
            if tool in tool_tips:
                selected_tips.extend(tool_tips[tool][:2])
        
        # Tips por intereses
        interests = session.preferences.get('interests', [])
        for interest in interests[:2]:  # Max 2 intereses
            if interest in interest_tips:
                selected_tips.extend(interest_tips[interest][:2])
        
        # Tip general si no hay suficientes
        if len(selected_tips) < 3:
            selected_tips.append("üí´ **General:** La pr√°ctica constante es clave en dise√±o")
            selected_tips.append("üîç **Explora:** Usa `/search` para descubrir nuevos recursos")
        
        # Construir mensaje
        tips_text = (
            "üí° **Tips Personalizados para Ti**\n\n"
            f"Basado en tu perfil: {level.title()}"
        )
        
        if session.favorite_tools:
            tips_text += f" | {', '.join(session.favorite_tools[:2])}"
        
        tips_text += "\n\n"
        
        # A√±adir tips seleccionados
        for i, tip in enumerate(selected_tips[:6], 1):
            tips_text += f"{i}. {tip}\n\n"
        
        tips_text += (
            "üöÄ **Siguiente paso:**\n"
            "‚Ä¢ Elige un tip y aplicalo en tu pr√≥ximo proyecto\n"
            "‚Ä¢ Usa `/search` para profundizar en temas espec√≠ficos\n"
            "‚Ä¢ Actualiza tus `/preferences` seg√∫n evoluciones"
        )
        
        # Botones de acci√≥n
        keyboard = types.InlineKeyboardMarkup()
        keyboard.add(
            types.InlineKeyboardButton("üîç Buscar recursos", callback_data="quick_search_resources"),
            types.InlineKeyboardButton("‚öôÔ∏è Actualizar perfil", callback_data="show_preferences")
        )
        keyboard.add(
            types.InlineKeyboardButton("üìä Ver progreso", callback_data="show_my_analytics")
        )
        
        self.bot.send_message(
            message.chat.id,
            tips_text,
            reply_markup=keyboard,
            parse_mode="Markdown"
        )

    def _handle_admin_callback(self, call):
        """Maneja callbacks espec√≠ficos de administraci√≥n"""
        action = call.data.replace("admin_", "")
        
        if action == "broadcast_confirm":
            self._execute_broadcast(call)
        elif action == "broadcast_cancel":
            self._cancel_broadcast(call)
        elif action == "trends":
            self._show_detailed_trends(call)
        elif action == "active_users":
            self._show_active_users_detail(call)
        # A√±adir m√°s handlers seg√∫n necesidad

    def _execute_broadcast(self, call):
        """Ejecuta el env√≠o de mensaje broadcast"""
        if not hasattr(self, '_temp_broadcast_message'):
            self.bot.answer_callback_query(call.id, "‚ùå Mensaje broadcast no encontrado")
            return
        
        message = self._temp_broadcast_message
        sent_count = 0
        failed_count = 0
        
        # Enviar a todos los usuarios activos
        for user_id in self.state_manager.active_sessions.keys():
            try:
                self.bot.send_message(user_id, f"üì¢ **Mensaje del equipo:**\n\n{message}", parse_mode="Markdown")
                sent_count += 1
            except Exception as e:
                failed_count += 1
                self.logger.warning(f"Error enviando broadcast a {user_id}: {e}")
        
        # Reportar resultados
        result_text = (
            f"üì¢ **Broadcast completado**\n\n"
            f"‚úÖ Enviado exitosamente: {sent_count}\n"
            f"‚ùå Fallos: {failed_count}\n"
            f"üìä Total intentos: {sent_count + failed_count}"
        )
        
        try:
            self.bot.edit_message_text(
                result_text,
                call.message.chat.id,
                call.message.message_id,
                parse_mode="Markdown"
            )
        except:
            self.bot.send_message(call.message.chat.id, result_text, parse_mode="Markdown")
        
        # Limpiar mensaje temporal
        delattr(self, '_temp_broadcast_message')

    def _cancel_broadcast(self, call):
        """Cancela el env√≠o de broadcast"""
        if hasattr(self, '_temp_broadcast_message'):
            delattr(self, '_temp_broadcast_message')
        
        try:
            self.bot.edit_message_text(
                "‚ùå **Broadcast cancelado**\n\nEl mensaje no fue enviado.",
                call.message.chat.id,
                call.message.message_id,
                parse_mode="Markdown"
            )
        except:
            self.bot.send_message(
                call.message.chat.id,
                "‚ùå **Broadcast cancelado**",
                parse_mode="Markdown"
            )

    # M√©todos auxiliares existentes contin√∫an...
    def show_help(self, message_or_call):
        """Muestra mensaje de ayuda completo"""
        help_text = (
            "üé® **DesignBot - Tu Asistente de UX/UI**\n\n"
            "**üöÄ Comandos Principales:**\n"
            "‚Ä¢ `/start` - Comenzar e inicializar perfil\n"
            "‚Ä¢ `/help` - Mostrar esta ayuda\n\n"
            "**üí¨ Consultas Especializadas:**\n"
            "‚Ä¢ `/design [pregunta]` - Consultas generales de dise√±o\n"
            "‚Ä¢ `/ux [pregunta]` - Preguntas espec√≠ficas sobre UX\n"
            "‚Ä¢ `/ui [pregunta]` - Preguntas espec√≠ficas sobre UI\n"
            "‚Ä¢ `/tools [pregunta]` - Informaci√≥n sobre herramientas\n"
            "‚Ä¢ `/ask [pregunta]` - Preguntas generales\n\n"
            "**üîç B√∫squeda Avanzada:**\n"
            "‚Ä¢ `/search [t√©rmino]` - Buscar en base de conocimientos\n"
            "‚Ä¢ `/trending` - Ver b√∫squedas populares\n\n"
            "**‚öôÔ∏è Personalizaci√≥n:**\n"
            "‚Ä¢ `/preferences` - Configurar perfil\n"
            "‚Ä¢ `/analytics` - Ver tus estad√≠sticas\n"
            "‚Ä¢ `/tips` - Consejos personalizados\n\n"
            "**üìö Recursos:**\n"
            "‚Ä¢ `/list` - Explorar categor√≠as de recursos\n\n"
            "üí° **Tip:** Tambi√©n puedes escribir directamente tus preguntas sin comandos."
        )
        
        keyboard = types.InlineKeyboardMarkup()
        keyboard.add(
            types.InlineKeyboardButton("üîç Buscar recursos", callback_data="quick_search_help"),
            types.InlineKeyboardButton("‚öôÔ∏è Configurar perfil", callback_data="show_preferences")
        )
        
        if hasattr(message_or_call, 'chat'):
            # Es un mensaje
            self.bot.send_message(
                message_or_call.chat.id,
                help_text,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )
        else:
            # Es un callback
            try:
                self.bot.edit_message_text(
                    help_text,
                    message_or_call.message.chat.id,
                    message_or_call.message.message_id,
                    reply_markup=keyboard,
                    parse_mode="Markdown"
                )
            except:
                self.bot.send_message(
                    message_or_call.message.chat.id,
                    help_text,
                    reply_markup=keyboard,
                    parse_mode="Markdown"
                )

    def list_categories(self, message):
        """Muestra categor√≠as de recursos disponibles"""
        categories_text = (
            "üìö **Explora Recursos por Categor√≠a**\n\n"
            "Selecciona una categor√≠a para ver los recursos disponibles:"
        )
        
        keyboard = types.InlineKeyboardMarkup()
        
        # Crear botones para cada categor√≠a
        categories = [
            ("ux_research", "üî¨ UX Research"),
            ("ui_patterns", "üñºÔ∏è UI Patterns"),
            ("design_systems", "üéØ Design Systems"),
            ("tools_guides", "üõ†Ô∏è Tools & Guides"),
            ("prototyping", "üîß Prototyping"),
            ("accessibility", "‚ôø Accessibility")
        ]
        
        for cat_id, cat_name in categories:
            keyboard.add(
                types.InlineKeyboardButton(
                    cat_name,
                    callback_data=f"list_{cat_id}"
                )
            )
        
        keyboard.add(
            types.InlineKeyboardButton("üîç B√∫squeda libre", callback_data="search_help")
        )
        
        self.bot.send_message(
            message.chat.id,
            categories_text,
            reply_markup=keyboard,
            parse_mode="Markdown"
        )

    def handle_list(self, call):
        """Maneja la selecci√≥n de categor√≠as de recursos"""
        category = call.data.replace("list_", "")
        
        category_info = {
            "ux_research": {
                "name": "üî¨ UX Research",
                "description": "M√©todos y t√©cnicas de investigaci√≥n de usuarios",
                "topics": [
                    "User interviews y encuestas",
                    "Personas y user journey mapping",
                    "Usability testing y an√°lisis",
                    "Research synthesis y insights"
                ]
            },
            "ui_patterns": {
                "name": "üñºÔ∏è UI Patterns",
                "description": "Patrones de interfaz y componentes de dise√±o",
                "topics": [
                    "Navigation patterns",
                    "Form design y inputs",
                    "Cards y layouts",
                    "Micro-interactions"
                ]
            },
            "design_systems": {
                "name": "üéØ Design Systems",
                "description": "Sistemas de dise√±o y componentes reutilizables",
                "topics": [
                    "Atomic design methodology",
                    "Design tokens y variables",
                    "Component libraries",
                    "Documentation y governance"
                ]
            },
            "tools_guides": {
                "name": "üõ†Ô∏è Tools & Guides",
                "description": "Gu√≠as de herramientas de dise√±o",
                "topics": [
                    "Figma advanced features",
                    "Sketch workflows",
                    "Adobe XD prototyping",
                    "Design handoff tools"
                ]
            },
            "prototyping": {
                "name": "üîß Prototyping",
                "description": "T√©cnicas de prototipado y testing",
                "topics": [
                    "Low-fi wireframing",
                    "Interactive prototypes",
                    "Animation y transitions",
                    "Prototype testing"
                ]
            },
            "accessibility": {
                "name": "‚ôø Accessibility",
                "description": "Dise√±o inclusivo y accesibilidad",
                "topics": [
                    "WCAG guidelines",
                    "Color y contrast",
                    "Screen reader optimization",
                    "Inclusive design patterns"
                ]
            }
        }
        
        if category in category_info:
            info = category_info[category]
            
            detail_text = (
                f"{info['name']}\n\n"
                f"üìã **Descripci√≥n:**\n{info['description']}\n\n"
                f"üìö **Temas principales:**\n"
            )
            
            for topic in info['topics']:
                detail_text += f"‚Ä¢ {topic}\n"
            
            detail_text += (
                f"\nüí° **Sugerencias:**\n"
                f"‚Ä¢ Usa `/search [tema]` para buscar contenido espec√≠fico\n"
                f"‚Ä¢ Combina t√©rminos para b√∫squedas m√°s precisas\n"
                f"‚Ä¢ Explora recursos relacionados en otras categor√≠as"
            )
            
            keyboard = types.InlineKeyboardMarkup()
            keyboard.add(
                types.InlineKeyboardButton(
                    f"üîç Buscar en {info['name']}",
                    callback_data=f"quick_search_{category}"
                )
            )
            keyboard.add(
                types.InlineKeyboardButton("‚¨ÖÔ∏è Volver a categor√≠as", callback_data="back_categories"),
                types.InlineKeyboardButton("üè† Men√∫ principal", callback_data="show_help")
            )
            
            try:
                self.bot.edit_message_text(
                    detail_text,
                    call.message.chat.id,
                    call.message.message_id,
                    reply_markup=keyboard,
                    parse_mode="Markdown"
                )
            except:
                self.bot.send_message(
                    call.message.chat.id,
                    detail_text,
                    reply_markup=keyboard,
                    parse_mode="Markdown"
                )
        else:
            self.bot.answer_callback_query(call.id, "Categor√≠a no encontrada")

    def handle_pdf_download(self, call):
        """Maneja la descarga de documentos PDF"""
        try:
            doc_path = call.data.replace("download#", "")
            full_path = os.path.join(DOCUMENTS_FOLDER, doc_path)
            
            if os.path.exists(full_path) and full_path.endswith('.pdf'):
                # Obtener informaci√≥n del archivo
                file_size = os.path.getsize(full_path)
                file_name = os.path.basename(full_path)
                
                # Verificar tama√±o del archivo (l√≠mite de Telegram: 50MB)
                if file_size > 50 * 1024 * 1024:
                    self.bot.answer_callback_query(
                        call.id,
                        "‚ùå Archivo demasiado grande para descargar por Telegram"
                    )
                    return
                
                # Enviar el archivo
                with open(full_path, 'rb') as doc:
                    self.bot.send_document(
                        call.message.chat.id,
                        doc,
                        caption=f"üìÑ **{file_name}**\n\nüí° Descargado desde DesignBot",
                        parse_mode="Markdown"
                    )
                
                self.bot.answer_callback_query(call.id, "‚úÖ Descarga iniciada")
                
                # Actualizar analytics
                user_id = call.from_user.id
                self.admin_service.update_analytics('download', {
                    'user_id': user_id,
                    'file_name': file_name,
                    'file_size': file_size,
                    'success': True
                })
                
            else:
                self.bot.answer_callback_query(call.id, "‚ùå Archivo no encontrado")
                
        except Exception as e:
            self.logger.error(f"Error en handle_pdf_download: {str(e)}")
            self.bot.answer_callback_query(call.id, "‚ùå Error al descargar archivo")

    def handle_back(self, call):
        """Maneja la navegaci√≥n hacia atr√°s"""
        action = call.data.replace("back_", "")
        
        if action == "categories":
            # Volver a la lista de categor√≠as
            categories_text = (
                "üìö **Explora Recursos por Categor√≠a**\n\n"
                "Selecciona una categor√≠a para ver los recursos disponibles:"
            )
            
            keyboard = types.InlineKeyboardMarkup()
            
            categories = [
                ("ux_research", "üî¨ UX Research"),
                ("ui_patterns", "üñºÔ∏è UI Patterns"),
                ("design_systems", "üéØ Design Systems"),
                ("tools_guides", "üõ†Ô∏è Tools & Guides"),
                ("prototyping", "üîß Prototyping"),
                ("accessibility", "‚ôø Accessibility")
            ]
            
            for cat_id, cat_name in categories:
                keyboard.add(
                    types.InlineKeyboardButton(
                        cat_name,
                        callback_data=f"list_{cat_id}"
                    )
                )
            
            keyboard.add(
                types.InlineKeyboardButton("üîç B√∫squeda libre", callback_data="search_help")
            )
            
            try:
                self.bot.edit_message_text(
                    categories_text,
                    call.message.chat.id,
                    call.message.message_id,
                    reply_markup=keyboard,
                    parse_mode="Markdown"
                )
            except:
                self.bot.send_message(
                    call.message.chat.id,
                    categories_text,
                    reply_markup=keyboard,
                    parse_mode="Markdown"
                )
        else:
            self.bot.answer_callback_query(call.id, "Acci√≥n no reconocida")

    def find_pdf_files(self, directory):
        """Encuentra todos los archivos PDF en el directorio y subdirectorios"""
        pdf_files = []
        for root, dirs, files in os.walk(directory):
            for file in files:
                if file.lower().endswith('.pdf'):
                    pdf_files.append(os.path.join(root, file))
        return pdf_files

    # ...resto de m√©todos existentes permanecen igual...
